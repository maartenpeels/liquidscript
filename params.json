{"name":"Liquidscript","tagline":"","body":"# ![Liquidscript](http://i.imgur.com/xbdhTsr.png)\r\n\r\n**A javascript-based language that compiles to javascript.**  It compiles directly to javascript, requiring no runtime libraries.  It means to take away the awkwardness of javascript, but keep the very essence and ideals of javascript.  It incorporates some of the most well-used concepts, and allows you to write the code as you like.\r\n\r\n## Installation\r\n\r\nAdd this line to your application's Gemfile:\r\n\r\n    gem 'liquidscript'\r\n\r\nAnd then execute:\r\n\r\n    $ bundle\r\n\r\nOr install it yourself as:\r\n\r\n    $ gem install liquidscript\r\n\r\n## Syntax\r\n\r\nLiquidscript has a very similar syntax to Javascript.\r\n\r\n\t# This is a comment\r\n\tsomething = 2\r\n    some_string = something.toString()\r\n    \r\n    if(some_string == '2) {\r\n      console.log(\"It lives!\")\r\n    }\r\n    \r\nThe thing that should stand out to you the most there is the lack of an end quote to the single quotes in the if conditional.  This is on purpose - a ending single quote is optional.\r\n\r\nNote that there are also no semicolons (they don't exist in the language), and no `var` statement.  The `var` statement is made automagically by liquidscript, so you don't have to.\r\n\r\n### Literals\r\n\r\n#### String\r\n\r\nLiquidscript has a very finite set of string literals - the only two options (so far) are double quotes and single quotes.  There are plans to introduce heredocs.  Double quotes are multiline, whereas **single quotes are limited to the same characters that identifiers are limited to**.  This is so that keys for objects (in the `object[key]` syntax feels more natural (i.e., `object['key]`).  Some examples:\r\n\r\n\tstring = \"hello\r\n    \r\n    world\" # this'll translate to \"hello\\n\\nworld\"\r\n    \r\n    single = 'test # there doesn't need to be an endquote here.\r\n    \r\nThat's it!\r\n\r\n#### Functions\r\n\r\nFunctions are defined using the arrow syntax:\r\n\r\n\tsome_function = -> {}\r\n    \r\nBrackets are **not** optional.  The parameter list before the arrow, however, is.  If you want something like coffeescript's fat arrow syntax, something like the following would have to be done:\r\n\r\n\tself = this\r\n    \r\n    some_function = -> {\r\n    \t# Change this to whatever property you wanted.\r\n    \tself.whatever\r\n    }\r\n    \r\nA parameter list works exactly like you'd expect:\r\n\r\n\tsome_function = (a, b, c)-> {\r\n    \tconsole.log(a, b, c)\r\n    }\r\n    \r\n    some_function(1, 2, 3)\r\n\r\n#### Numeric\r\n\r\nThere are numbers in liquidscript as well.  It follows the JSON spec on this to the letter.\r\n\r\n\tsome_number = -2e+5\r\n\r\n#### Array, Object\r\n\r\nArrays and objects are exactly like in javascript:\r\n\r\n\tarray = [1, \"test\", 'foo, bar]\r\n    \r\n    object = {\r\n    \ttest: \"hello\",\r\n        foo: \"world\" # a colon here is allowed\r\n    }\r\n    \r\n### Controls\r\n\r\nLiquidscript has control statements like `if`, and `else`.  Liquidscript uses `elsif` instead of `else if`.\r\n    \r\n    if(some_variable == 2) {\r\n    \tconsole.log(\"It's 2!\")\r\n    } elsif(some_variable == 3) {\r\n    \tconsole.log(\"It's a 3!\")\r\n    } else {\r\n    \tconsole.log(\"I don't know what it is!\")\r\n    }\r\n\r\nLiquidscript lacks `for`, `switch`, and `while`, but they will be added as well.\r\n\r\n### Classes and Modules\r\n\r\n#### Modules\r\nThis is where liquidscript gets interesting, in my opinion.  Modules are extreme syntaxic sugar:\r\n\r\n\tmodule SomeModule {\r\n    \tVERSION: \"1.7.0\"\r\n    }\r\n    \r\n    SomeModule.VERSION # => 1.7.0\r\n    \r\nThat compiles directly to:\r\n\r\n\tvar SomeModule;\r\n    SomeModule = {\r\n    \tVERSION: \"1.7.0\"\r\n    };\r\n    \r\n    SomeModule.VERSION; // => 1.7.0\r\n    \r\nThe point of modules, however, is to bind code together into units, in an easier to read syntax.  Commas are not needed between definitions, and other modules and classes can be defined within modules.\r\n\r\n\tmodule SomeModule {\r\n    \tmodule OtherModule {\r\n        \tVERSION: \"1.7.0\"\r\n            VERSION_MAJOR: 1\r\n            VERSION_MINOR: 7\r\n            VERSION_PATCH: 0\r\n            \r\n            version: -> {\r\n            \treturn SomeModule.OtherModule.VERSION.split('.')\r\n            }\r\n        }\r\n    }\r\n    \r\nWhich compiles directly to:\r\n\r\n\tvar SomeModule, OtherModule;\r\n    \r\n    SomeModule = {\r\n    \tOtherModule: {\r\n        \tVERSION: \"1.7.0\",\r\n            VERSION_MAJOR: 1,\r\n            VERSION_MINOR: 7,\r\n            VERSION_PATCH: 0,\r\n            version: function() {\r\n            \treturn SomeModule.OtherModule.VERSION.split('.');\r\n            }\r\n        }\r\n    };\r\n    \r\n#### Classes\r\n\r\nClasses are meant to be instantized with the `new` keyword.  They are defined very similarly to modules, but when values are defined, they default to being defined on the instance of the class:\r\n\r\n\tclass Greeter {\r\n    \t# This is a special function that is called whenever a \r\n        # new greeter is created.\r\n    \tinitialize: (name)-> {\r\n        \tthis.name = name\r\n        }\r\n        \r\n        greet: -> {\r\n        \tconsole.log(\"Hello #{this.name}!\")\r\n        }\r\n    }\r\n    \r\n    new Greeter(\"Alice\").greet()\r\n    \r\nThis would translate directly to this:\r\n\r\n\tvar Greeter;\r\n    \r\n    Greeter = function Greeter() {\r\n    \tif(this.initialize) {\r\n        \tthis.initialize.apply(this, arguments);\r\n        }\r\n    };\r\n    \r\n    Greeter.prototype.initialize = function(name) {\r\n    \tthis.name = name;\r\n    };\r\n    \r\n    Greeter.prototype.greet = function() {\r\n    \tconsole.log(\"Hello \" + (this.name) + \"!\");\r\n    };\r\n    \r\n    new Greeter(\"Alice\").greet();\r\n    \r\nThis uses the functional prototype system in order to create instances of classes.  Inheritance is not yet supported, but there will be progress towards it.\r\n\r\nIf you want a method defined on the class itself instead of the instance, prefix the function name with `this`:\r\n\r\n\tclass Greeter {\r\n    \t# This is a special function that is called whenever a \r\n        # new greeter is created.\r\n    \tinitialize: (name)-> {\r\n        \tthis.name = name\r\n        }\r\n        \r\n        greet: -> {\r\n        \tconsole.log(\"Hello #{this.name}!\")\r\n        }\r\n        \r\n        this.meet: (first, second)-> {\r\n        \tnew Greeter(first).greet()\r\n            new Greeter(second).greet()\r\n        }\r\n    }\r\n    \r\n   \tGreeter.meet(\"Alice\", \"Bob\")\r\n    \r\nThis translates roughly to:\r\n\r\n\t// ...\r\n    \r\n    Greeter.meet = function(first, second) {\r\n    \tnew Greeter(first).greet();\r\n        new Greeter(second).greet();\r\n    }\r\n    \r\n    // ...\r\n    \r\n# The End!\r\n\r\nThat wraps it all up!  If you're interested in more, checkout the [github repository](https://github.com/redjazz96/liquidscript) and read the documentation.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}